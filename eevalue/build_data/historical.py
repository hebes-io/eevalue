# -*- coding: utf-8 -*-
# Copyright (c) Hebes Intelligence Private Company

# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

from pathlib import Path

import intake
import numpy as np
import pandas as pd
from scipy.signal import savgol_filter

from eevalue.exceptions import NotEnoughData
from eevalue.utils import expand_dates, match_period

###############################################################################################
# Build individual datasets
###############################################################################################


def build_availability(period: pd.DatetimeIndex, country: str, data_dir: Path):
    """Build the availability factors for dispatchable generation.

    Args:
        period (pandas.DatetimeIndex with freq='H'): The period over which to gather the data.
        country (str): The country to load the data for (in ISO 3166-1 alpha-2 format).
        data_dir (pathlib.Path): Path to data generated by the `preprocess` stage.

    Returns:
        pandas.DataFrame: The availability time series data for each cluster.
    """
    years = np.unique(period.year)
    results = []

    for year in years:
        # available capacity
        capacity = pd.read_csv(
            data_dir / "capacity" / country / str(year) / "clustered.csv",
            parse_dates=["ds"],
        )
        if capacity.empty:
            raise NotEnoughData(
                "Available capacity data is empty. No data was found "
                f"for the selected period {period.min()} - {period.max()}"
            )

        capacity = (
            capacity.set_index("ds")
            .pipe(expand_dates)
            .pipe(match_period, period=period[period.year == year])
        )

        # total capacity
        total = pd.read_csv(
            data_dir / "plants" / country / str(year) / "clustered.csv"
        )[["Fuel", "Technology", "TotalCapacity"]]
        total = total.set_index(
            total[["Technology", "Fuel"]].agg("_".join, axis=1)
        ).drop(["Fuel", "Technology"], axis=1)
        results.append(capacity.div(total["TotalCapacity"]))

    results = pd.concat(results, axis=0).sort_index()
    return results


def build_demand(period: pd.DatetimeIndex, country: str):
    """Build the demand data.

    Args:
        period (pandas.DatetimeIndex with freq='H'): The period over which to gather the data.
        country (str): The country to load the data for (in ISO 3166-1 alpha-2 format).

    Returns:
        pandas.DataFrame: The demand time series data (including 2U and 2D reserves).
    """
    demand = (
        intake.cat["markets"]
        .load(country=country)
        .read()
        .set_index("ds")
        .pipe(expand_dates)
        .pipe(match_period, period=period)
    )
    demand = demand.rename(columns={demand.columns[0]: "DA"})

    try:
        resv = (
            intake.cat["markets"]
            .reserves(country=country)
            .read()
            .set_index("ds")
            .pipe(expand_dates)
            .pipe(match_period, period=period)
        )
        demand = pd.concat([demand, resv], axis=1)
    except FileNotFoundError:
        resv = demand.groupby(lambda x: x.date).apply(
            lambda x: np.sqrt(10 * x.max() + 22500) - 150
        )
        resv.index = resv.index.map(pd.to_datetime)
        demand = pd.concat(
            [
                demand,
                resv.rename(columns={resv.columns[0]: "2U"}),
                resv.multiply(0.5).rename(columns={resv.columns[0]: "2D"}),
            ],
            axis=1,
        )
    finally:
        return demand


def build_fuel_prices(
    period: pd.DatetimeIndex,
    country: str,
    fuels: list = ["GAS", "COAL", "LIG", "OIL", "WAT"],
):
    """Build the fuel price data.

    Args:
        period (pandas.DatetimeIndex with freq='H'): The period over which to gather the data.
        country (str): The country to load the data for (in ISO 3166-1 alpha-2 format).
        fuels (list, optional): The fuels for which to gather prices. Defaults to
            ["GAS", "COAL", "LIG", "OIL", "WAT"]

    Returns:
        pandas.DataFrame: The fuel price time series data.
    """
    price_data = []

    if "GAS" in fuels:
        try:
            gas = intake.cat["markets"].ngas_price(country=country).read()
        except FileNotFoundError:
            gas = intake.cat["markets"].ngas_price(country="EU").read()
        gas = (
            gas.set_index("ds")
            .resample("H")
            .asfreq()
            .pipe(expand_dates)
            .pipe(match_period, period=period)
        )
        price_data.append(gas)

    if "COAL" in fuels:
        try:
            coal = intake.cat["markets"].coal_price(country=country).read()
        except FileNotFoundError:
            coal = intake.cat["markets"].coal_price(country="EU").read()
        coal = (
            coal.set_index("ds")
            .resample("H")
            .asfreq()
            .pipe(expand_dates)
            .pipe(match_period, period=period)
        )
        price_data.append(coal)

    if "LIG" in fuels:
        try:
            if country == "EL":
                lignite = (
                    intake.cat["markets"]
                    .lignite_price(
                        country=country, csv_kwargs={"date_format": "%d-%m-%y"}
                    )
                    .read()
                )
                lignite["ds"] = pd.to_datetime(lignite["ds"], format="%d-%m-%y")
                lignite = lignite.set_index("ds")
            else:
                lignite = (
                    intake.cat["markets"]
                    .lignite_price(country=country)
                    .read()
                    .set_index("ds")
                )

            lignite = (
                lignite.resample("H")
                .asfreq()
                .pipe(expand_dates)
                .pipe(match_period, period=period)
            )
        except FileNotFoundError as exc:
            raise ValueError(
                f"Lignite price data for country {country} not found"
            ) from exc

        price_data.append(lignite)

    if "OIL" in fuels:
        try:
            oil = intake.cat["markets"].oil_price(country=country).read()
        except FileNotFoundError:
            oil = intake.cat["markets"].oil_price(country="EU").read()
        oil = (
            oil.set_index("ds")
            .resample("H")
            .asfreq()
            .pipe(expand_dates)
            .pipe(match_period, period=period)
        )
        price_data.append(oil)

    if "WAT" in fuels:
        price_data.append(pd.DataFrame(0, index=period, columns=["WAT"]))

    return pd.concat(price_data, axis=1)


def build_imports(period: pd.DatetimeIndex, country: str):
    """Build the power imports data.

    Args:
        period (pandas.DatetimeIndex with freq='H'): The period over which to gather the data.
        country (str): The country to load the data for (in ISO 3166-1 alpha-2 format).

    Returns:
        pandas.Series: The net power imports time series data.
    """
    imports = (
        intake.cat["markets"]
        .imports(country=country)
        .read()
        .set_index("ds")
        .pipe(expand_dates)
        .pipe(match_period, period=period)
    )
    return imports["Imports [MW]"]


def build_exports(period: pd.DatetimeIndex, country: str):
    """Build the power exports data.

    Args:
        period (pandas.DatetimeIndex with freq='H'): The period over which to gather the data.
        country (str): The country to load the data for (in ISO 3166-1 alpha-2 format).

    Returns:
        pandas.Series: The net power imports time series data.
    """
    exports = (
        intake.cat["markets"]
        .exports(country=country)
        .read()
        .set_index("ds")
        .pipe(expand_dates)
        .pipe(match_period, period=period)
    )
    return exports["Exports [MW]"]


def build_carbon_price(period: pd.DatetimeIndex, country: str):
    """Build the carbon price data.

    Args:
        period (pandas.DatetimeIndex with freq='H'): The period over which to gather the data.
        country (str): The country to load the data for (in ISO 3166-1 alpha-2 format).

    Returns:
        pandas.Series: The carbon price time series data.
    """
    try:
        price = intake.cat["markets"].carbon_price(country=country).read()
    except FileNotFoundError:
        price = intake.cat["markets"].carbon_price(country="EU").read()
    price = (
        price.set_index("ds")
        .resample("H")
        .asfreq()
        .pipe(expand_dates)
        .pipe(match_period, period=period)
    )
    return price["CRBN"]


def build_available_capacity(period: pd.DatetimeIndex, country: str, data_dir: Path):
    """Build the available capacity for dispatchable generation.

    Args:
        period (pandas.DatetimeIndex with freq='H'): The period over which to gather the data.
        country (str): The country to load the data for (in ISO 3166-1 alpha-2 format).
        data_dir (pathlib.Path): Path to data generated by the `preprocess` stage.

    Returns:
        pandas.DataFrame: The available capacity data for each cluster.
    """
    years = np.unique(period.year)
    results = []

    for year in years:
        results.append(
            pd.read_csv(
                data_dir / "capacity" / country / str(year) / "clustered.csv",
                parse_dates=["ds"],
            )
            .set_index("ds")
            .pipe(expand_dates)
            .pipe(match_period, period=period[period.year == year])
        )

    results = pd.concat(results, axis=0).sort_index()
    return results


def build_res_generation(period: pd.DatetimeIndex, country: str):
    """Build the data for renewable generation.

    Args:
        period (pandas.DatetimeIndex with freq='H'): The period over which to gather the data.
        country (str): The country to load the data for (in ISO 3166-1 alpha-2 format).

    Returns:
        pandas.DataFrame: The generation time series data for renewables.
    """
    res = (
        intake.cat["markets"]
        .res(country=country)
        .read()
        .set_index("ds")
        .pipe(expand_dates)
        .pipe(match_period, period=period)
    )
    return res["RES generation [MW]"]


def build_committed_capacity(period: pd.DatetimeIndex, country: str, data_dir: Path):
    """Build the committed capacity data for dispatchable generation.

    Args:
        period (pandas.DatetimeIndex with freq='H'): The period over which to gather the data.
        country (str): The country to load the data for (in ISO 3166-1 alpha-2 format).
        data_dir (pathlib.Path): Path to data generated by the `preprocess` stage.

    Returns:
        pandas.DataFrame: The committed capacity time series data for each cluster.
    """
    years = np.unique(period.year)
    results = []

    for year in years:
        results.append(
            pd.read_csv(
                data_dir / "generation" / country / str(year) / "clustered.csv",
                parse_dates=["ds"],
            )
            .set_index("ds")
            .pipe(expand_dates)
            .pipe(match_period, period=period[period.year == year])
        )

    results = pd.concat(results, axis=0).sort_index()
    return results


def build_water_value(period: pd.DatetimeIndex, country: str):
    """Build the data for the water value.

    Args:
        period (pandas.DatetimeIndex with freq='H'): The period over which to gather the data.
        country (str): The country to load the data for (in ISO 3166-1 alpha-2 format).

    Returns:
        pandas.Series: The water value time series data.
    """
    reservoirs = (
        intake.cat["markets"]
        .reservoirs(country=country)
        .read()
        .set_index("ds")
        .filter(like="Average")
        .pipe(expand_dates)
        .pipe(match_period, period=period)
    )
    water_value = reservoirs["LT_Average"] / reservoirs["Average"]
    return pd.Series(
        data=savgol_filter(water_value, 337, 3), index=water_value.index
    )  # window size of 14 days, polynomial order 3


###################################################################################
# Create the dataset for simulation
###################################################################################


def create_historical_data(
    *, period: pd.DatetimeIndex, country: str, config: dict, data_dir: Path
) -> dict:
    """Create the dataset for historical simulation.

    Args:
        period (pandas.DatetimeIndex with freq='H'): The period over which to gather
            the data.
        country (str): The country to load the data for (in ISO 3166-1 alpha-2 format).
        config (dict): A configuration dictionary with simulation parameter values.
        data_dir (pathlib.Path): Path to data generated by the `preprocess` stage.

    Returns:
        dict: Dictionary with all simulation data.
    """
    dataset = {}
    dataset["simulation_period"] = period

    years = np.unique(period.year)

    dataset["clustered_plants"] = pd.read_csv(
        data_dir / "plants" / country / str(years.min()) / "clustered.csv"
    )

    # Time series
    dataset["avail_factors"] = build_availability(period, country, data_dir)
    dataset["demand"] = build_demand(period, country)
    dataset["available_capacity"] = build_available_capacity(period, country, data_dir)
    dataset["committed_capacity"] = build_committed_capacity(period, country, data_dir)
    dataset["net_imports"] = build_imports(period, country).add(
        build_exports(period, country)
    )
    dataset["res_generation"] = build_res_generation(period, country)

    fuels = dataset["clustered_plants"]["Fuel"].unique()
    dataset["fuel_price"] = build_fuel_prices(period, country, fuels=fuels)
    dataset["permit_price"] = build_carbon_price(period, country)

    if "WAT" in fuels:
        dataset["water_value"] = build_water_value(period, country)

        if (dataset["fuel_price"]["WAT"] == 0).all():
            var_cost_water = 0
            for cluster in dataset["available_capacity"]:
                _, fuel = cluster.split("_")
                if fuel == "WAT":
                    continue

                efficiency, emission_rate = (
                    dataset["clustered_plants"]
                    .loc[dataset["clustered_plants"]["Cluster"] == cluster][
                        ["Efficiency", "CO2Intensity"]
                    ]
                    .iloc[0, :]
                )
                var_cost = dataset["fuel_price"][fuel].div(efficiency) + dataset[
                    "permit_price"
                ].mul(emission_rate)

                var_cost_water += var_cost.mul(dataset["available_capacity"][cluster])

            var_cost_water = (
                var_cost_water.div(dataset["available_capacity"].sum(axis=1))
                .fillna(method="ffill")
                .fillna(method="bfill")
            )
            dataset["fuel_price"]["WAT"] = var_cost_water

    # Non-time series
    dataset["reserve_technologies"] = config["Market"].get(
        "ReserveParticipation",
        dataset["clustered_plants"]["Technology"].unique().tolist(),
    )
    dataset["voll"] = config["Market"].get("VOLL")
    dataset["committed_initial"] = config["Market"].get("committed_initial")
    dataset["power_initial"] = config["Market"].get("power_initial")
    dataset["storage_initial"] = config["Market"].get("storage_initial")
    dataset["storage_charge_ef"] = config["Market"].get("StorageChargingEfficiency")
    dataset["storage_discharge_ef"] = config["Market"].get("StorageDischargeEfficiency")
    dataset["storage_capacity"] = config["Market"].get("StorageCapacity")
    dataset["storage_charge_cap"] = config["Market"].get("StorageChargingCapacity")
    dataset["storage_min"] = config["Market"].get("StorageMinimum")
    dataset["storage_final_min"] = config["Market"].get("StorageFinalMin")

    return dataset
